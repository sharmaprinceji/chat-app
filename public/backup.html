<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>TalkSphere</title>
    <style>
      /* ======== VARIABLES ======== */
      :root {
        --accent: #df5555;
        --green: #28a745;
      }

      /* ======== GLOBAL ======== */
      body {
        margin: 0;
        font-family: Arial, sans-serif;
        background: #fafafa;
      }

      h1,
      h2 {
        margin: 0;
      }

      /* ========== Responsive Logo ========== */
      .header h1 {
        font-size: clamp(20px, 5vw, 28px);
        /* shrink with screen */
        display: flex;
        align-items: center;
        gap: 6px;
        color: var(--accent);
      }

      .header h1 span.logo {
        font-size: clamp(22px, 6vw, 32px);
        /* logo emoji adjusts too */
      }

      /* ========== Mobile mode adjustments ========== */
      @media (max-width: 600px) {
        .app {
          flex-direction: column;
          align-items: stretch;
        }

        .left-panel,
        .chat-area {
          width: 100%;
        }

        /* By default hide chat-area when in private/group until user selected */
        .chat-area.hidden {
          display: none;
        }
      }

      /* ======== HEADER ======== */
      .header {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 20px;
        padding: 18px;
        background: #fff;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.08);
        position: relative;
      }

      /* Current user container */
      #current-user {
        display: flex;
        align-items: center;
        position: relative;
        cursor: pointer;
        gap: 8px;
      }

      /* Profile image */
      #profilePic {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        object-fit: cover;
        border: 2px solid white;
        cursor: pointer;
      }

      /* Dropdown */
      .dropdown {
        display: none;
        position: absolute;
        top: 50px;
        right: 0;
        background: #fff;
        color: #333;
        border-radius: 8px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        min-width: 150px;
        z-index: 100;
        flex-direction: column;
      }

      .dropdown-item {
        padding: 10px 15px;
        cursor: pointer;
        transition: 0.2s;
      }

      .dropdown-item:hover {
        background: #f2f2f2;
      }

      /* Show dropdown when active */
      #current-user.show-dropdown .dropdown {
        display: flex;
      }

      #logout-option {
        position: absolute;
        top: 100%;
        left: 0;
        background: #fff;
        border: 1px solid #ccc;
        padding: 5px 10px;
        border-radius: 6px;
        font-size: 14px;
        cursor: pointer;
        display: none;
        white-space: nowrap;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }

      #logout-option:hover {
        background: #f5f5f5;
      }

      /* ======== PROFILE MODAL ======== */

      .profile-modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 3000;
      }

      .profile-card {
        background: #fff;
        padding: 20px;
        border-radius: 12px;
        text-align: center;
        width: 320px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        position: relative;
      }

      .profile-large {
        width: 120px;
        height: 120px;
        border-radius: 50%;
        object-fit: cover;
        border: 3px solid var(--accent);
        margin-bottom: 10px;
      }

      .close-btn {
        position: absolute;
        top: 12px;
        right: 16px;
        font-size: 26px;
        cursor: pointer;
        color: #555;
      }

      /* ======== APP LAYOUT ======== */
      .app {
        display: flex;
        gap: 20px;
        justify-content: center;
        padding: 10px;
      }

      .left-panel {
        width: 220px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      /*========== chat box and input row ==========*/
      #chatTitle {
        display: none;
        /* by default hide */
      }

      .chat-area {
        width: 640px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .chat-box {
        background: #fff;
        border-radius: 8px;
        height: 420px;
        padding: 12px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .input-row {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .input-wrapper {
        position: relative;
        flex: 1;
      }

      #fileBtn {
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        cursor: pointer;
        font-size: 18px;
        user-select: none;
      }

      .input {
        width: 100%;
        padding: 12px;
        border-radius: 20px;
        border: 1px solid #ddd;
        font-size: 14px;
        box-sizing: border-box;
        text-align: center;
      }

      .btn {
        padding: 10px 16px;
        border-radius: 20px;
        background: var(--green);
        color: #fff;
        border: none;
        cursor: pointer;
      }

      #emojiBtn {
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        cursor: pointer;
        font-size: 20px;
        user-select: none;
      }

      emoji-picker {
        position: absolute;
        bottom: 110%;
        right: 0;
        z-index: 1000;
        width: 320px;
        max-height: 360px;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);
      }

      /*========== end chat box and input row ==========*/

      /* ======== CARDS & LISTS ======== */

      .card {
        background: #fff;
        border-radius: 10px;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.06);
        padding: 12px;
      }

      .modes {
        display: flex;
        gap: 8px;
        justify-content: center;
      }

      .user-list {
        max-height: 420px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .user-item {
        padding: 8px;
        border-radius: 8px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .user-item:hover {
        background: #f3f3f3;
      }

      .badge {
        background: red;
        color: white;
        border-radius: 50%;
        padding: 2px 6px;
        font-size: 12px;
        margin-left: 6px;
      }

      /*======== CHAT BOX ========*/

      .chat-header {
        position: sticky;
        top: 0;
        background: #fff;
        z-index: 10;
        padding: 8px;
        border-bottom: 1px solid #ddd;
        display: none;
        align-items: center;
        gap: 8px;
        cursor: pointer;
      }

      .back-btn {
        display: none;
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        color: var(--accent);
      }

      /* Mobile: show back button */
      @media (max-width: 600px) {
        .back-btn {
          display: flex;
        }

        .chat-header {
          display: flex;
        }
      }

      /* Make only messages scroll */
      .chat-area {
        display: flex;
        flex-direction: column;
        height: 100%;
      }

      /* .chat-box {
        flex: 1;
        overflow-y: auto;
        padding: 10px;
      } */

      .input-row {
        position: sticky;
        bottom: 0;
        background: #fff;
        padding: 8px;
        border-top: 1px solid #ddd;
        z-index: 10;
      }

      .chat-box {
        background: #fff;
        border-radius: 8px;
        height: 420px;
        padding: 12px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .input-row {
        display: flex;
        gap: 8px;
      }

      .input {
        flex: 1;
        padding: 12px;
        border-radius: 20px;
        border: 1px solid #ddd;
        font-size: 14px;
      }

      .btn {
        padding: 10px 16px;
        border-radius: 20px;
        background: var(--green);
        color: #fff;
        border: none;
        cursor: pointer;
      }

      .message {
        max-width: 70%;
        padding: 8px 12px;
        border-radius: 12px;
        word-wrap: break-word;
      }

      .message.me {
        background: #dcf8c6;
        align-self: flex-end;
        text-align: right;
      }

      .message.other {
        background: #f1f0f0;
        align-self: flex-start;
        text-align: left;
      }

      .meta {
        font-size: 12px;
        color: gray;
        margin-top: 6px;
      }

      /* Fullscreen image modal */
      .img-modal {
        display: none;
        position: fixed;
        z-index: 2000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        justify-content: center;
        align-items: center;
      }

      .img-modal img {
        max-width: 90%;
        max-height: 90%;
        border-radius: 8px;
      }

      .img-modal span {
        position: absolute;
        top: 20px;
        right: 35px;
        font-size: 40px;
        color: white;
        cursor: pointer;
      }

      .coming-soon {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 320px;
        color: gray;
        font-style: italic;
      }

      #loginOverlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.35);
      }

      .login-card {
        width: 360px;
        padding: 16px;
        border-radius: 8px;
        background: #fff;
      }

      .login-card input {
        width: 95%;
        padding: 8px;
        margin-top: 6px;
        border-radius: 6px;
        border: 1px solid #ddd;
      }

      .login-card .btn {
        width: 100%;
        margin-top: 12px;
      }

      /* Delete button styling for each message */
      .message {
        position: relative;
        /* anchor for absolute delete button */
      }

      .delete-small {
        position: absolute;
        top: 6px;
        right: 6px;
        display: none;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        border: 1px solid #eee;
        background: #fff;
        font-size: 14px;
        line-height: 1;
        cursor: pointer;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
        padding: 0;
      }

      /* when toggled on (after dblclick) show delete button */
      .message.show-delete .delete-small {
        display: flex;
      }

      @media (max-width: 900px) {
        .app {
          flex-direction: column;
          align-items: center;
        }

        .left-panel,
        .chat-area {
          width: 95%;
        }
      }
    </style>

    <!-- load the emoji-picker once -->
    <script
      type="module"
      src="https://cdn.jsdelivr.net/npm/emoji-picker-element@^1/index.js"
    ></script>
  </head>

  <body>
    <!-- HEADER -->
    <div class="header">
      <h1>TalkSphere üéôÔ∏è</h1>

      <div id="current-user">
        <!-- Profile picture -->
        <img
          id="profilePic"
          src="https://images.pexels.com/photos/1704488/pexels-photo-1704488.jpeg"
          alt="profile"
        />

        <!-- First name -->
        <span id="username"></span>

        <div id="logout-option">Logout</div>

        <!-- Dropdown toggle (click on img) -->
        <div id="profileDropdown" class="dropdown">
          <label for="profileUpload" class="dropdown-item"
            >Change Profile</label
          >
          <input type="file" id="profileUpload" style="display: none" />
          <!-- <div id="logout-option" class="dropdown-item">Logout</div> -->
        </div>
      </div>
    </div>

    <!-- APP LAYOUT -->
    <div class="app">
      <div class="left-panel">
        <div class="card">
          <div style="text-align: center; margin-bottom: 8px; font-weight: 600">
            Mode
          </div>
          <div class="modes">
            <label
              ><input type="radio" name="mode" value="public" /> Public</label
            >
            <label
              ><input type="radio" name="mode" value="private" /> Private</label
            >
            <label
              ><input type="radio" name="mode" value="group" /> Group</label
            >
          </div>
        </div>

        <div class="card" id="usersCard" style="margin-top: 10px">
          <div style="font-weight: 600; margin-bottom: 8px">Users / Groups</div>
          <div class="user-list" id="leftList"></div>
        </div>
      </div>

      <div class="chat-area">
        <div class="chat-header">
          <button id="backBtn" class="back-btn">‚Üê Go Back</button>
        </div>

        <div class="card chat-box" id="chatBox"></div>

        <div class="input-row" style="display: none">
          <div class="input-wrapper">
            <span id="fileBtn">üìé</span>
            <input type="file" id="fileInput" style="display: none" />
            <input id="messageInput" class="input" placeholder="message..." />
            <span id="emojiBtn">üòä</span>
            <!-- initially hidden -->
            <emoji-picker id="emojiPicker" style="display: none"></emoji-picker>
          </div>
          <button id="sendBtn" class="btn">Send</button>
        </div>
      </div>

      <!-- Fullscreen image preview modal -->
      <div id="imgModal" class="img-modal">
        <span id="closeModal">&times;</span>
        <img id="modalImg" />
      </div>
    </div>

    <!-- LOGIN / SIGNUP OVERLAY -->
    <div id="loginOverlay">
      <div class="login-card card">
        <h2 style="margin: 0; color: var(--accent)">Welcome to TalkSphere</h2>
        <div style="display: flex; gap: 12px; margin: 12px 0">
          <button
            id="showLogin"
            class="btn"
            style="flex: 1; background: var(--accent)"
          >
            Login
          </button>
          <button
            id="showSignup"
            class="btn"
            style="flex: 1; background: var(--green)"
          >
            Signup
          </button>
        </div>

        <div id="loginForm">
          <p style="color: gray; margin: 6px 0">Enter username & login</p>
          <label>Username</label>
          <input id="loginUserName" placeholder="yourUser123" />
          <button id="loginBtn" class="btn">Login</button>
        </div>

        <div id="signupForm" style="display: none">
          <p style="color: gray; margin: 6px 0">
            Enter Name, Email & unique Username
          </p>
          <label>Name</label><input id="signupName" /> <label>Email</label
          ><input id="signupEmail" /> <label>Username</label
          ><input id="signupUserName" placeholder="abc1234" />
          <button id="signupBtn" class="btn">Signup</button>
        </div>
      </div>
    </div>

    <!-- Socket.io -->
    <script src="/socket.io/socket.io.js"></script>

    <script>
      // ========== DOM refs ==========
      const socket = io();

      const loginOverlay = document.getElementById("loginOverlay");
      const loginForm = document.getElementById("loginForm");
      const signupForm = document.getElementById("signupForm");
      const loginUserName = document.getElementById("loginUserName");
      const signupName = document.getElementById("signupName");
      const signupEmail = document.getElementById("signupEmail");
      const signupUserName = document.getElementById("signupUserName");
      const loginBtn = document.getElementById("loginBtn");
      const signupBtn = document.getElementById("signupBtn");
      const showLogin = document.getElementById("showLogin");
      const showSignup = document.getElementById("showSignup");

      const usernameSpan = document.getElementById("username");
      const currentUserDiv = document.getElementById("current-user");
      const logoutOption = document.getElementById("logout-option");
      const leftList = document.getElementById("leftList");
      const chatBox = document.getElementById("chatBox");
      const messageInput = document.getElementById("messageInput");
      const sendBtn = document.getElementById("sendBtn");
      const inputRow = document.querySelector(".input-row");
      const chatHeader = document.querySelector(".chat-header");
      const userCard = document.getElementById("usersCard");
      // const modesBtns = document.querySelectorAll('input[name="mode"]');

      const emojiBtn = document.getElementById("emojiBtn");
      const emojiPicker = document.getElementById("emojiPicker");

      // file attachment button (non-functional placeholder)
      const fileBtn = document.getElementById("fileBtn");
      const fileInput = document.getElementById("fileInput");
      let selectedFile = null;

      fileBtn.addEventListener("click", () => {
        fileInput.click();
      });

      fileInput.addEventListener("change", () => {
        if (fileInput.files.length > 0) {
          selectedFile = fileInput.files[0];

          // show preview in chatBox footer or above input
          const previewId = "file-preview";
          let existing = document.getElementById(previewId);
          if (existing) existing.remove();

          const preview = document.createElement("div");
          preview.id = previewId;
          preview.style.margin = "6px 0";
          preview.style.fontSize = "13px";
          preview.style.color = "gray";
          preview.style.display = "flex";
          preview.style.alignItems = "center";
          preview.style.gap = "6px";

          // small thumbnail if image
          if (selectedFile.type.startsWith("image/")) {
            const img = document.createElement("img");
            img.src = URL.createObjectURL(selectedFile);
            img.style.width = "40px";
            img.style.height = "40px";
            img.style.borderRadius = "6px";
            preview.appendChild(img);
          }

          const nameSpan = document.createElement("span");
          nameSpan.textContent = selectedFile.name;
          preview.appendChild(nameSpan);

          // cancel button
          const cancelBtn = document.createElement("button");
          cancelBtn.textContent = "‚úñ";
          cancelBtn.style.border = "none";
          cancelBtn.style.background = "transparent";
          cancelBtn.style.cursor = "pointer";
          cancelBtn.onclick = () => {
            selectedFile = null;
            preview.remove();
            fileInput.value = ""; // reset input
          };
          preview.appendChild(cancelBtn);

          document.querySelector(".chat-area").appendChild(preview);
        }
      });

      // ========== state ==========
      let token = localStorage.getItem("token") || null;
      let me = { name: null, email: null, userName: null };
      let mode = localStorage.getItem("mode") || "public";
      let selectedPrivate = localStorage.getItem("selectedPrivate") || null;
      let unreadCounts = {};
      let allUsers = [];

      // ========== UI toggles ==========
      showLogin.onclick = () => {
        loginForm.style.display = "block";
        signupForm.style.display = "none";
      };

      showSignup.onclick = () => {
        loginForm.style.display = "none";
        signupForm.style.display = "block";
      };

      // ========== login/signup ==========
      signupBtn.addEventListener("click", async () => {
        const n = signupName.value.trim(),
          e = signupEmail.value.trim(),
          u = signupUserName.value.trim();
        if (!n || !e || !u) return alert("Fill all fields");
        try {
          const res = await fetch("/api/v1/login", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              name: n,
              email: e,
              userName: u,
              exist: false,
            }),
          });
          const data = await res.json();
          if (!res.ok) return alert(data.message || "Signup failed");
          token = data.token;
          localStorage.setItem("token", token);
          me = data.user;
          localStorage.setItem("name", me.name);
          localStorage.setItem("email", me.email);
          localStorage.setItem("userName", me.userName);
          loginOverlay.style.display = "none";
          usernameSpan.textContent = me.name;
          socket.emit("identify", { userName: me.userName });
          await onModeChange();
          inputRow.style.display = "flex";
        } catch (err) {
          console.error(err);
          alert("Signup failed");
        }
      });

      loginBtn.addEventListener("click", async () => {
        const u = loginUserName.value.trim();
        if (!u) return alert("Enter username");
        try {
          const res = await fetch("/api/v1/login", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ userName: u, exist: true }),
          });
          const data = await res.json();
          if (!res.ok) return alert(data.message || "Login failed");
          token = data.token;
          localStorage.setItem("token", token);
          me = data.user;
          localStorage.setItem("name", me.name);
          localStorage.setItem("email", me.email);
          localStorage.setItem("userName", me.userName);
          loginOverlay.style.display = "none";
          usernameSpan.textContent = me.name;
          socket.emit("identify", { userName: me.userName });
          await onModeChange();
          inputRow.style.display = "flex";
        } catch (err) {
          console.error(err);
          alert("Login failed");
        }
      });

      // autologin
      window.addEventListener("DOMContentLoaded", async () => {
        const sname = localStorage.getItem("name");
        const semail = localStorage.getItem("email");
        const suser = localStorage.getItem("userName");
        const smode = localStorage.getItem("mode");
        const sselected = localStorage.getItem("selectedPrivate");
        if (sname && semail && suser) {
          me = { name: sname, email: semail, userName: suser };
          loginOverlay.style.display = "none";
          usernameSpan.textContent = me.name;
          if (smode) mode = smode;
          document
            .querySelectorAll('input[name="mode"]')
            .forEach((r) => (r.checked = r.value === mode));
          if (sselected) selectedPrivate = sselected;
          socket.emit("identify", { userName: me.userName });
          await onModeChange();
          inputRow.style.display = "flex";
          if (mode === "public") {
            chatHeader.style.display = "none";
            userCard.style.display = "none";
          } else {
            chatHeader.style.display = "flex";
            userCard.style.display = "block";
          }
        } else {
          if (smode) {
            mode = smode;
            document
              .querySelectorAll('input[name="mode"]')
              .forEach((r) => (r.checked = r.value === mode));
          }
        }
      });

      // ========== UI Profile logic code  ==========
      document.addEventListener("DOMContentLoaded", () => {
        const profilePic = document.getElementById("profilePic");
        const profileDropdown = document.getElementById("profileDropdown");
        const logoutOption = document.getElementById("logout-option");
        const profileUpload = document.getElementById("profileUpload");
        const usernameSpan = document.getElementById("username");

        let token = localStorage.getItem("token");

        // ---------- Dropdown toggle ----------
        profilePic.addEventListener("click", () => {
          document
            .getElementById("current-user")
            .classList.toggle("show-dropdown");
        });

        // ---------- Logout ----------
        // logoutOption.addEventListener("click", () => {
        //   localStorage.removeItem("token");
        //   window.location.reload();
        // });

        // ---------- Change Profile Picture ----------
        profileUpload.addEventListener("change", async (e) => {
          const file = e.target.files[0];
          if (!file) return;

          const username = localStorage.getItem("userName"); // saved at login
          if (!username) {
            alert("No username found in localStorage!");
            return;
          }

          const formData = new FormData();
          formData.append("file", file);

          // Debugging: check file actually added
          // for (let [key, value] of formData.entries()) {
          //   console.log(`${key}:`, value);
          // }

          try {
            const res = await fetch(`/api/v1/uploadAvatar/${username}`, {
              method: "POST",
              body: formData,
            });

            const data = await res.json();
            if (!res.ok)
              throw new Error(data.message || "Profile update failed");
            // Update UI
            profilePic.src = data.avatarUrl;
            alert("Profile updated successfully!");
          } catch (err) {
            console.error("Profile update error:", err);
            alert("Failed to update profile");
          }
        });

        // ---------- Profile Modal ----------
        function openProfileModal(user) {
          // Create modal wrapper
          const modal = document.createElement("div");
          modal.className = "profile-modal";
          modal.innerHTML = `
      <div class="profile-card">
        <span class="close-btn">&times;</span>
        <img src="${
          user.avatar || "default-avatar.png"
        }" alt="profile" class="profile-large" />
        <h2>${user.name}</h2>
        <p><b>Username:</b> ${user.username}</p>
        <p><b>Email:</b> ${user.email}</p>
        <p><b>Phone:</b> ${user.phone || "N/A"}</p>
        <p><b>Role:</b> ${user.role}</p>
      </div>
    `;
          document.body.appendChild(modal);

          // Close modal
          modal.querySelector(".close-btn").addEventListener("click", () => {
            modal.remove();
          });
        }

        // ---------- Fetch user details on load ----------
        async function loadUserProfile() {
          if (!token) return;
          try {
            const res = await fetch("/api/v1/getUser", {
              headers: { Authorization: "Bearer " + token },
            });
            const data = await res.json();
            if (!res.ok)
              throw new Error(data.message || "Failed to fetch user");

            // Update header
            usernameSpan.textContent = data.name.split(" ")[0]; // first name
            if (data.profilePic) {
              profilePic.src = data.avatar;
            }

            // Open profile modal when clicking username
            usernameSpan.addEventListener("click", () =>
              openProfileModal(data)
            );
          } catch (err) {
            console.error("Get user error:", err);
          }
        }

        loadUserProfile();
      });

      // logout
      currentUserDiv.addEventListener("click", (e) => {
        e.stopPropagation();
        logoutOption.style.display =
          logoutOption.style.display === "block" ? "none" : "block";
      });

      logoutOption.addEventListener("click", () => {
        localStorage.clear();
        socket.disconnect();
        location.reload();
      });

      document.addEventListener("click", () => {
        logoutOption.style.display = "none";
      });

      // modes
      document.querySelectorAll('input[name="mode"]').forEach((r) => {
        r.checked = r.value === mode;
        r.addEventListener("change", async (e) => {
          mode = e.target.value;
          localStorage.setItem("mode", mode);
          selectedPrivate = null;
          localStorage.removeItem("selectedPrivate");
          await onModeChange();
          if (mode === "public") {
            chatHeader.style.display = "none";
            userCard.style.display = "none";
          } else {
            chatHeader.style.display = "flex";
            userCard.style.display = "block";
          }
        });
      });

      // ========== Emoji picker logic (fixed) ==========
      // Toggle picker visibility (stop propagation so outside click handler won't immediately hide)
      emojiBtn.addEventListener("click", (ev) => {
        ev.stopPropagation();
        emojiPicker.style.display =
          emojiPicker.style.display === "block" ? "none" : "block";
      });

      // robust handler to extract emoji string from event detail
      function extractEmojiFromDetail(detail) {
        if (!detail) return "";
        // common: detail.unicode
        if (detail.unicode) return detail.unicode;
        // some builds: detail.emoji might be a string or an object
        if (typeof detail.emoji === "string") return detail.emoji;
        if (detail.emoji && typeof detail.emoji === "object") {
          // try several property names
          return (
            detail.emoji.unicode ||
            detail.emoji.character ||
            detail.emoji.native ||
            detail.emoji.shortcode ||
            ""
          );
        }
        // fallback: detail has 'shortcode' or 'native' or 'character'
        return detail.shortcode || detail.native || detail.character || "";
      }

      // handler to insert emoji into input
      function onEmojiPicked(e) {
        try {
          e.stopPropagation();
          const emojiStr = extractEmojiFromDetail(e.detail);
          if (!emojiStr) return;
          // insert emoji at caret position if desired, for now append
          const start =
            messageInput.selectionStart || messageInput.value.length;
          const end = messageInput.selectionEnd || start;
          const before = messageInput.value.slice(0, start);
          const after = messageInput.value.slice(end);
          messageInput.value = before + emojiStr + after;
          // move caret after inserted emoji
          const caretPos = start + emojiStr.length;
          messageInput.focus();
          messageInput.setSelectionRange(caretPos, caretPos);
          // hide picker after selection
          emojiPicker.style.display = "none";
        } catch (err) {
          console.error("emoji handler err:", err);
        }
      }

      // attach both directly to the element and to document as fallback
      try {
        if (emojiPicker) {
          emojiPicker.addEventListener("emoji-click", onEmojiPicked);
        }
        document.addEventListener("emoji-click", onEmojiPicked);
      } catch (err) {
        console.warn("Failed to attach emoji listeners:", err);
      }

      // hide picker when clicking outside
      document.addEventListener("click", (e) => {
        if (!emojiPicker.contains(e.target) && e.target !== emojiBtn) {
          emojiPicker.style.display = "none";
        }
      });

      // ========== helpers & chat logic (kept intact) ==========
      function clearChat() {
        chatBox.innerHTML = "";
      }
      function timeHM(d) {
        return new Date(d).toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        });
      }

      // REPLACE existing appendMessage with this (returns the element)
      function appendMessage(m) {
        const el = document.createElement("div");
        el.className = "message " + (m.by === me.userName ? "me" : "other");

        // store server id if present
        if (m._id) el.dataset.msgId = m._id;
        else if (m.id) el.dataset.msgId = m.id;

        // store client-side temp id if present (used to patch local messages after server ack)
        if (m.clientTempId) el.dataset.tempId = m.clientTempId;

        // build inner HTML
        let inner = `<div><strong>${
          m.by === me.userName ? "You" : m.by
        }</strong></div>`;

        if (m.text) {
          // escape HTML minimally to avoid injection (simple)
          const escaped = String(m.text)
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;");
          inner += `<div>${escaped}</div>`;
        }

        if (m.file) {
          if (m.file.mimetype && m.file.mimetype.startsWith("image/")) {
            inner += `<div><img src="${m.file.url}" style="max-width:180px;border-radius:6px;margin-top:6px"/></div>`;
          } else {
            inner += `<div><a href="${m.file.url}" target="_blank">${
              m.file.originalname || "file"
            }</a></div>`;
          }
        }

        inner += `<div class="meta">${timeHM(m.time)}</div>`;

        el.innerHTML = inner;

        // Who can delete? (message author or admin)
        const canDelete =
          (me && me.userName && m.by === me.userName) ||
          (me && me.role === "admin");

        if (canDelete) {
          // create small delete button (hidden by default)
          const delBtn = document.createElement("button");
          delBtn.className = "delete-small";
          delBtn.title = "Delete message";
          delBtn.type = "button";
          delBtn.innerHTML = "üóë";

          // delete click handler
          delBtn.addEventListener("click", async (ev) => {
            ev.stopPropagation();
            // console.log("Current token before delete:", token);
            const id = el.dataset.msgId;
            if (!id) {
              return alert("Cannot delete: message id not available yet.");
            }
            if (!token) {
              return alert("Login required to delete messages");
            }

            // UI feedback
            delBtn.disabled = true;
            const prev = delBtn.innerHTML;
            delBtn.innerHTML = "‚Ä¶";

            try {
              // Determine whether this message is private.
              // Prefer explicit m.chatType if present (messages loaded from server),
              // otherwise fall back to current UI mode.
              const isPrivate =
                (m.chatType && m.chatType === "private") || mode === "private";

              const endpoint = isPrivate
                ? `/api/v1/messages/private/${id}`
                : `/api/v1/messages/${id}`;

              // call correct endpoint
              const res = await fetch(endpoint, {
                method: "DELETE",
                headers: {
                  Authorization: "Bearer " + token,
                  "Content-Type": "application/json",
                },
              });

              const data = await res.json();
              console.log("delete response", data);
              if (!res.ok) throw new Error(data.message || "Delete failed");

              // remove locally (server will broadcast too)
              el.remove();
            } catch (err) {
              console.error("delete error", err);
              alert("Delete failed: " + (err.message || "unknown"));
              delBtn.disabled = false;
              delBtn.innerHTML = prev;
            }
          });

          el.appendChild(delBtn);

          // dblclick toggles the delete button visibility
          el.addEventListener("dblclick", (e) => {
            e.stopPropagation();
            // toggle show-delete class
            el.classList.toggle("show-delete");
            // optional: auto-hide after 4 seconds
            setTimeout(() => el.classList.remove("show-delete"), 5000);
          });
        }

        chatBox.appendChild(el);
        chatBox.scrollTop = chatBox.scrollHeight;
        return el;
      }

      async function fetchUsers() {
        try {
          const res = await fetch("/api/v1/users");
          const data = await res.json();
          allUsers = data;
          renderUserList(data);
        } catch (err) {
          console.error("fetch users error", err);
        }
      }

      // updated version of renderUserList with improved logic
      function renderUserList(users) {
        leftList.innerHTML = "";

        // hide list in public mode
        if (mode === "public") {
          leftList.style.display = "none";
          return;
        } else {
          leftList.style.display = "block";
        }

        if (mode === "group") {
          ["QA Team", "Ops", "Managers"].forEach((g) => {
            const it = document.createElement("div");
            it.className = "user-item";
            it.textContent = g;
            it.onclick = () => {
              selectedPrivate = g; // simulate group selection
              localStorage.setItem("selectedPrivate", selectedPrivate);

              // in phone view, show chat and hide list
              if (window.innerWidth <= 600) {
                document.querySelector(".chat-area").classList.remove("hidden");
                document.querySelector(".left-panel").style.display = "none";
              }

              clearChat();
              const el = document.createElement("div");
              el.className = "coming-soon";
              el.textContent = "Group chat coming soon.";
              chatBox.appendChild(el);
            };
            leftList.appendChild(it);
          });
          return;
        }

        users.forEach((u) => {
          if (u.userName === me.userName) return;
          const it = document.createElement("div");
          it.className = "user-item";
          let badge = "";
          if (unreadCounts[u.userName] && unreadCounts[u.userName] > 0)
            badge = `<span class="badge">${unreadCounts[u.userName]}</span>`;
          it.innerHTML = `<div>${u.name}<div style="font-size:11px;color:gray">@${u.userName}</div></div>${badge}`;
          it.onclick = async () => {
            selectedPrivate = u.userName;
            localStorage.setItem("selectedPrivate", selectedPrivate);
            unreadCounts[u.userName] = 0;
            renderUserList(allUsers);
            await loadPrivate(selectedPrivate);

            // in phone view, show chat and hide list
            if (window.innerWidth <= 600) {
              document.querySelector(".chat-area").classList.remove("hidden");
              document.querySelector(".left-panel").style.display = "none";
            }
          };
          leftList.appendChild(it);
        });
      }

      async function loadPublic() {
        clearChat();
        try {
          const res = await fetch("/api/v1/messages/public");
          const data = await res.json();
          data.forEach((m) => appendMessage(m));
        } catch (err) {
          console.error(err);
        }
      }

      async function loadPrivate(other) {
        clearChat();
        try {
          const res = await fetch(
            `/api/v1/messages/private/${me.userName}/${other}`
          );
          const data = await res.json();
          if (!data.length) {
            const node = document.createElement("div");
            node.className = "coming-soon";
            node.textContent = "No messages yet ‚Äî start the conversation.";
            chatBox.appendChild(node);
            return;
          }
          data.forEach((m) => appendMessage(m));
        } catch (err) {
          console.error(err);
        }
      }

      // updated version of onModeChange with improved logic
      // When switching mode, adjust view for mobile
      async function onModeChange() {
        clearChat();

        // reset phone responsive UI
        document.querySelector(".chat-area").classList.remove("hidden");
        document.querySelector(".left-panel").style.display = "block";

        if (mode === "public") {
          await fetchUsers();
          await loadPublic();
        } else if (mode === "private") {
          await fetchUsers();

          if (window.innerWidth <= 600 && !selectedPrivate) {
            // hide chat until user picks someone
            document.querySelector(".chat-area").classList.add("hidden");
          }

          if (selectedPrivate) await loadPrivate(selectedPrivate);
        } else if (mode === "group") {
          fetchUsers();

          if (window.innerWidth <= 600 && !selectedPrivate) {
            document.querySelector(".chat-area").classList.add("hidden");
          }

          const el = document.createElement("div");
          el.className = "coming-soon";
          el.textContent = "Group functionality coming soon.";
          chatBox.appendChild(el);
        }
      }

      // send message
      sendBtn.addEventListener("click", async () => {
        const txt = messageInput.value.trim();

        // case: no text & no file ‚Üí ignore
        if (!txt && !selectedFile) return;

        if (!me.userName) return alert("Login first");

        let fileData = null;

        // if file exists ‚Üí upload to server first
        if (selectedFile) {
          const formData = new FormData();
          formData.append("file", selectedFile);

          try {
            const res = await fetch("/api/v1/upload", {
              method: "POST",
              body: formData,
            });
            const data = await res.json();
            if (!data.success) throw new Error("Upload failed");

            fileData = data.file; // contains {url, public_id, originalname, mimetype}
          } catch (err) {
            console.error("File upload failed:", err);
            return alert("File upload failed");
          }
        }

        // prepare message data
        const msgData = {
          name: me.name,
          email: me.email,
          userName: me.userName,
          message: txt || null,
          file: fileData || null,
          time: new Date(),
          chatType: mode,
        };
        if (mode === "private") {
          if (!selectedPrivate) return alert("Select user for private chat");
          msgData.to = selectedPrivate;
        }

        // client-generated temp id to patch local element after server ack
        const clientTempId =
          "temp_" + Date.now() + "_" + Math.floor(Math.random() * 10000);
        msgData.clientTempId = clientTempId;

        // emit to server
        socket.emit("chat msg", msgData);

        // append message locally and tag it with temp id
        const el = appendMessage({
          text: msgData.message,
          file: msgData.file,
          by: me.userName,
          time: msgData.time,
          clientTempId: clientTempId,
        });

        if (el) el.dataset.tempId = clientTempId;

        // reset inputs
        messageInput.value = "";
        selectedFile = null;
        const preview = document.getElementById("file-preview");
        if (preview) preview.remove();
        fileInput.value = "";
      });

      socket.on("receive_msg", (data) => {
        if (!me.userName) return;

        const from = data.userName;
        const chatType = data.chatType;

        // helper to safely append msg
        function safeAppend(payload) {
          appendMessage({
            text: payload.message,
            file: payload.file || null,
            by: payload.userName || payload.by,
            time: payload.time,
            _id: payload._id || payload.id,
            clientTempId: payload.clientTempId,
          });
        }

        // PUBLIC / GROUP message
        if (chatType === "public" || chatType === "group") {
          // if this is an ack for our own message (server returned saved msg with clientTempId)
          if (from === me.userName && data.clientTempId) {
            const local = document.querySelector(
              `.message[data-temp-id="${data.clientTempId}"]`
            );
            if (local) {
              // set real server id so delete will work
              if (data._id) local.dataset.msgId = data._id;
              else if (data.id) local.dataset.msgId = data.id;

              // update time (if server normalized it)
              const meta = local.querySelector(".meta");
              if (meta) meta.textContent = timeHM(data.time);
              return; // done; don't duplicate
            }
          }

          // otherwise append for others
          if (from !== me.userName) {
            safeAppend(data);
          } else {
            // if from me but no clientTempId & no local match ‚Üí append to keep consistent
            safeAppend(data);
          }
          return;
        }

        // PRIVATE message
        if (chatType === "private") {
          const fromUser = data.userName;
          const toUser = data.to;

          // if this is related to currently open private chat
          if (
            (fromUser === me.userName && toUser === selectedPrivate) ||
            (toUser === me.userName && fromUser === selectedPrivate)
          ) {
            // handle our own message ack via clientTempId
            if (fromUser === me.userName && data.clientTempId) {
              const local = document.querySelector(
                `.message[data-temp-id="${data.clientTempId}"]`
              );
              if (local) {
                if (data._id) local.dataset.msgId = data._id;
                else if (data.id) local.dataset.msgId = data.id;
                const meta = local.querySelector(".meta");
                if (meta) meta.textContent = timeHM(data.time);
                return;
              }
            }

            // append message for matched private chat
            safeAppend(data);
            return;
          }

          // incoming private message to me but not current open user ‚Üí unread
          if (toUser === me.userName) {
            const fromWho = fromUser;
            unreadCounts[fromWho] = (unreadCounts[fromWho] || 0) + 1;
            renderUserList(allUsers);
          }
        }
      });

      // Show user list updates and toggle to back to user list on mobile
      const backBtn = document.getElementById("backBtn");
      const chatTitle = document.getElementById("chatTitle");

      function openChat(userOrGroup) {
        selectedPrivate = userOrGroup;
        localStorage.setItem("selectedPrivate", selectedPrivate);

        // Hide list, show chat
        if (window.innerWidth <= 600) {
          document.querySelector(".chat-area").classList.remove("hidden");
          document.querySelector(".left-panel").style.display = "none";
        }

        chatTitle.textContent = userOrGroup; // show name at top
        clearChat();
        loadPrivate(userOrGroup); // or group
      }

      backBtn.addEventListener("click", () => {
        if (window.innerWidth <= 600) {
          document.querySelector(".chat-area").classList.add("hidden");
          document.querySelector(".left-panel").style.display = "block";
        }
      });

      // ========== image modal logic ==========
      // Image modal preview
      const imgModal = document.getElementById("imgModal");
      const modalImg = document.getElementById("modalImg");
      const closeModal = document.getElementById("closeModal");

      // Event delegation: listen for clicks on chatBox images
      chatBox.addEventListener("click", (e) => {
        if (e.target.tagName === "IMG" && e.target.closest(".message")) {
          modalImg.src = e.target.src;
          imgModal.style.display = "flex";
        }
      });

      // Close modal on X click
      closeModal.addEventListener("click", () => {
        imgModal.style.display = "none";
      });

      // Close modal on background click
      imgModal.addEventListener("click", (e) => {
        if (e.target === imgModal) {
          imgModal.style.display = "none";
        }
      });

      //---------delete chat history on double click of header ---------//
      socket.on("messageDeleted", ({ id }) => {
        // support both .message and .msg selectors (compatibility)
        const msgDiv =
          document.querySelector(`.message[data-msg-id="${id}"]`) ||
          document.querySelector(`.msg[data-id="${id}"]`);

        if (msgDiv) {
          msgDiv.remove();
        }
      });
    </script>
  </body>
</html>
